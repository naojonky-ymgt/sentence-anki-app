<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Anki (Kind Mode)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: #f0f2f5; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; padding: 20px; color: #333; }
        .card { background: white; width: 100%; max-width: 500px; padding: 40px 20px; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); text-align: center; }
        .status { font-size: 14px; color: #888; margin-bottom: 20px; }
        .japanese { font-size: 24px; font-weight: bold; margin-bottom: 20px; line-height: 1.4; }
        .english { font-size: 20px; color: #007bff; margin-bottom: 30px; min-height: 30px; font-weight: 500; opacity: 0; transition: opacity 0.3s; }
        .english.visible { opacity: 1; }
        
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        button { border: none; padding: 15px; border-radius: 12px; font-size: 16px; cursor: pointer; font-weight: bold; transition: background 0.2s; }
        
        .btn-mic-toggle { grid-column: span 2; background: #333; color: white; font-size: 18px; position: relative; overflow: hidden; }
        .btn-mic-toggle.active { background: #2ed573; }
        .mic-icon { margin-right: 8px; }
        .ripple { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 0; height: 0; background: rgba(255,255,255, 0.4); border-radius: 50%; pointer-events: none; }
        .btn-mic-toggle.active .ripple { animation: rippleEffect 2s infinite; }

        .btn-show { background: #f1f2f6; color: #333; }
        .btn-play { background: #f1f2f6; color: #333; }
        .btn-next { grid-column: span 2; background: #3742fa; color: white; margin-top: 10px; }

        .result-msg { margin-top: 15px; font-weight: bold; min-height: 24px; word-break: break-all; }
        .correct { color: #2ed573; }
        .close-call { color: #ffa502; } /* ãŠã¾ã‘åˆæ ¼ç”¨ */
        .incorrect { color: #ff4757; }
        .listening-text { font-size: 12px; color: #aaa; margin-top: 5px; min-height: 18px; }

        details { width: 100%; max-width: 500px; margin-top: 30px; text-align: left; }
        textarea { width: 100%; height: 150px; margin-top: 10px; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-family: monospace; white-space: pre; overflow-x: scroll; }
        .btn-save { background: #333; color: white; width: 100%; margin-top: 5px; }

        @keyframes rippleEffect { 0% { width: 0; height: 0; opacity: 1; } 100% { width: 400px; height: 400px; opacity: 0; } }
    </style>
</head>
<body>

<div class="card">
    <div class="status" id="counter">1 / 5</div>
    <div class="japanese" id="jp-text">èª­ã¿è¾¼ã¿ä¸­...</div>
    <div class="english" id="en-text">Loading...</div>
    
    <div class="result-msg" id="result-msg"></div>
    <div class="listening-text" id="listening-text">...</div>

    <div class="controls">
        <button class="btn-mic-toggle" id="btn-mic" onclick="toggleSession()">
            <span class="mic-icon">ğŸ¤</span><span id="mic-label">ãƒã‚¤ã‚¯ONã«ã™ã‚‹ (é–‹å§‹)</span>
            <div class="ripple"></div>
        </button>
        <button class="btn-show" onclick="toggleAnswer()">ç­”ãˆã‚’è¦‹ã‚‹</button>
        <button class="btn-play" onclick="playAudio(true)">ğŸ”Š ãŠæ‰‹æœ¬</button>
        <button class="btn-next" onclick="nextCard()">æ¬¡ã®ã‚«ãƒ¼ãƒ‰ã¸ â¡</button>
    </div>
</div>

<details>
    <summary>ğŸ“ ä¾‹æ–‡ãƒ‡ãƒ¼ã‚¿ã®ç·¨é›† (Excelã‹ã‚‰ã‚³ãƒ”ãƒšOK)</summary>
    <textarea id="data-input"></textarea>
    <button class="btn-save" onclick="saveData()">ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¦æ›´æ–°</button>
</details>

<script>
    // ==========================================
    // â–¼ã“ã“ã«ä¾‹æ–‡ã‚’ã€Œæ—¥æœ¬èª(ã‚¿ãƒ–)è‹±èªã€ã§æ›¸ã„ã¦ãã ã•ã„
    // ==========================================
    const defaultData = `
ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’æ‹…å½“ã—ã¦ã„ã¾ã™ã€‚	I am in charge of this project.
ä¼šè­°ã¯ä½•æ™‚ã«å§‹ã¾ã‚Šã¾ã™ã‹ï¼Ÿ	What time does the meeting start?
ã¾ã çµ‚ã‚ã£ã¦ã„ã¾ã›ã‚“ã€‚	I haven't finished yet.
è©³ç´°ã‚’ãƒ¡ãƒ¼ãƒ«ã§é€ã£ã¦ãã ã•ã„ã€‚	Please send me the details by email.
ãŠå¾…ãŸã›ã—ã¦ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚	I'm sorry for keeping you waiting.
`;
    // ==========================================

    // â˜…å„ªã—ã•è¨­å®š: 0.7 = 70%åˆã£ã¦ã„ã‚Œã°æ­£è§£ã¨ã™ã‚‹
    const PASS_THRESHOLD = 0.70; 

    let sentences = [];
    let currentIndex = 0;
    let recognition = null;
    let isSessionActive = false;
    let isSpeaking = false;

    const jpText = document.getElementById('jp-text');
    const enText = document.getElementById('en-text');
    const resultMsg = document.getElementById('result-msg');
    const listeningText = document.getElementById('listening-text');
    const btnMic = document.getElementById('btn-mic');
    const micLabel = document.getElementById('mic-label');
    const counter = document.getElementById('counter');
    const dataInput = document.getElementById('data-input');

    function init() {
        const savedData = localStorage.getItem('mySentences_tab_v2');
        if (savedData) {
            parseData(savedData);
            dataInput.value = savedData;
        } else {
            const cleanData = defaultData.trim();
            parseData(cleanData);
            dataInput.value = cleanData;
        }
        setupRecognition();
        showCard();
    }

    function parseData(text) {
        const lines = text.split('\n');
        const newSentences = [];
        lines.forEach(line => {
            if(!line.trim()) return;
            let parts = line.split('\t');
            if (parts.length < 2) parts = line.split('|');
            if(parts.length >= 2) {
                const jp = parts[0].trim();
                const en = parts[1].trim();
                if(jp && en) newSentences.push({ jp, en });
            }
        });
        if(newSentences.length > 0) {
            sentences = newSentences;
            return true;
        }
        return false;
    }

    function setupRecognition() {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) return;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        recognition.lang = 'en-US';
        recognition.continuous = true;
        recognition.interimResults = false;

        recognition.onresult = (event) => {
            if (!isSessionActive || isSpeaking) return;
            const lastResultIndex = event.results.length - 1;
            const transcript = event.results[lastResultIndex][0].transcript;
            listeningText.innerText = `èãå–ã‚Šä¸­: "${transcript}"`;
            checkAnswer(transcript);
        };

        recognition.onerror = (event) => {
            console.error(event.error);
            if(event.error === 'not-allowed') {
                alert("ãƒã‚¤ã‚¯è¨±å¯ãŒå¿…è¦ã§ã™ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
                stopSession();
            }
        };

        recognition.onend = () => {
            if (isSessionActive) {
                setTimeout(() => { try { recognition.start(); } catch(e){} }, 500);
            }
        };
    }

    function toggleSession() {
        if (!recognition) { alert("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“"); return; }
        if (isSessionActive) stopSession();
        else startSession();
    }

    function startSession() {
        try {
            recognition.start();
            isSessionActive = true;
            btnMic.classList.add('active');
            micLabel.innerText = "ãƒã‚¤ã‚¯ONä¸­ (ä¼šè©±ã—ã¦å›ç­”)";
            resultMsg.innerText = "ğŸ¤ ãŠè©±ã—ãã ã•ã„...";
        } catch(e) { console.error(e); }
    }

    function stopSession() {
        isSessionActive = false;
        recognition.stop();
        btnMic.classList.remove('active');
        micLabel.innerText = "ãƒã‚¤ã‚¯ONã«ã™ã‚‹ (é–‹å§‹)";
        listeningText.innerText = "...";
    }

    function showCard() {
        if(sentences.length === 0) return;
        const item = sentences[currentIndex];
        jpText.innerText = item.jp;
        enText.innerText = item.en;
        enText.classList.remove('visible');
        resultMsg.innerText = isSessionActive ? "ğŸ¤ ãŠè©±ã—ãã ã•ã„..." : "";
        resultMsg.className = "result-msg";
        listeningText.innerText = "...";
        counter.innerText = `${currentIndex + 1} / ${sentences.length}`;
    }

    function nextCard() {
        currentIndex = (currentIndex + 1) % sentences.length;
        showCard();
    }

    function toggleAnswer() {
        enText.classList.toggle('visible');
    }

    function playAudio(force = false) {
        if(sentences.length === 0) return;
        isSpeaking = true; 
        const u = new SpeechSynthesisUtterance(sentences[currentIndex].en);
        u.lang = 'en-US';
        u.onend = () => {
            isSpeaking = false;
            if(!force) setTimeout(nextCard, 1500); 
        };
        speechSynthesis.speak(u);
    }

    // â–¼â–¼â–¼ ã“ã“ãŒæ–°ã—ããªã£ãŸåˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ â–¼â–¼â–¼
    function checkAnswer(spokenText) {
        const correctText = sentences[currentIndex].en;
        const normalize = (str) => str.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();
        
        const spokenClean = normalize(spokenText);
        const correctClean = normalize(correctText);

        // é¡ä¼¼åº¦(0.0ã€œ1.0)ã‚’è¨ˆç®—
        const similarity = getSimilarity(spokenClean, correctClean);
        const similarityPercent = Math.round(similarity * 100);

        if (similarity >= PASS_THRESHOLD) {
            // åˆæ ¼ãƒ©ã‚¤ãƒ³ã‚’è¶…ãˆãŸã‚‰
            if (similarity === 1.0) {
                resultMsg.innerText = `â­• Perfect! (${similarityPercent}%)`;
                resultMsg.className = "result-msg correct";
            } else {
                // å®Œç’§ã˜ã‚ƒãªã„ã‘ã©åˆæ ¼ï¼ˆãŠã¾ã‘åˆæ ¼ï¼‰
                resultMsg.innerText = `ğŸ†— Good! (${similarityPercent}%) - You said: "${spokenText}"`;
                resultMsg.className = "result-msg close-call";
            }
            enText.classList.add('visible');
            playAudio(false); 
        } else {
            // ä¸åˆæ ¼
            resultMsg.innerText = `âŒ Match: ${similarityPercent}% ... You said: "${spokenText}"`;
            resultMsg.className = "result-msg incorrect";
        }
    }

    // ãƒ¬ãƒ¼ãƒ™ãƒ³ã‚·ãƒ¥ã‚¿ã‚¤ãƒ³è·é›¢ã«ã‚ˆã‚‹é¡ä¼¼åº¦è¨ˆç®—é–¢æ•°
    function getSimilarity(s1, s2) {
        let longer = s1;
        let shorter = s2;
        if (s1.length < s2.length) { longer = s2; shorter = s1; }
        const longerLength = longer.length;
        if (longerLength === 0) return 1.0;
        return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);
    }

    function editDistance(s1, s2) {
        s1 = s1.toLowerCase();
        s2 = s2.toLowerCase();
        const costs = new Array();
        for (let i = 0; i <= s1.length; i++) {
            let lastValue = i;
            for (let j = 0; j <= s2.length; j++) {
                if (i === 0) costs[j] = j;
                else {
                    if (j > 0) {
                        let newValue = costs[j - 1];
                        if (s1.charAt(i - 1) !== s2.charAt(j - 1)) newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
            }
            if (i > 0) costs[s2.length] = lastValue;
        }
        return costs[s2.length];
    }
    // â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²

    function saveData() {
        const rawText = dataInput.value;
        if(parseData(rawText)) {
            localStorage.setItem('mySentences_tab_v2', rawText);
            currentIndex = 0;
            showCard();
            alert("æ›´æ–°ã—ã¾ã—ãŸï¼");
        } else {
            alert("ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„");
        }
    }

    init();
</script>

</body>
</html>
